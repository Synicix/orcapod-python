from typing import Protocol
from orcapod.types import DataValue, TypeSpec
from orcapod.protocols.hashing_protocols import ContentIdentifiable
from collections.abc import Iterator, Collection
import pyarrow as pa
from datetime import datetime


class Datagram(Protocol):
    @property
    def typespec(self) -> TypeSpec: ...

    def keys(self) -> Collection[str]: ...

    def as_table(self) -> pa.Table: ...

    def as_dict(self) -> dict[str, DataValue]: ...


class Tag(Datagram, Protocol): ...


class Packet(Datagram, Protocol):
    def as_table(self, include_source: bool = False) -> pa.Table:
        """
        Convert the packet to a PyArrow Table.
        If include_source is True, the source information is included in the table.
        """
        ...

    def as_dict(self, include_source: bool = False) -> dict[str, DataValue]:
        """
        Convert the packet to a dictionary.
        If include_source is True, the source information is included in the dictionary.
        """
        ...

    def content_hash(self) -> str: ...

    def source_info(self) -> dict[str, str | None]: ...

    # def join(self, other: "Packet") -> "Packet": ...

    # def get_as(self, packet_type: PacketType) -> PacketType: ...


class PodFunction(Protocol):
    """
    A function suitable to be used in a FunctionPod.
    It takes one or more named arguments, each corresponding to either:
    - A path to a file or directory (PathSet) - for backward compatibility
    - A simple data value (str, int, float, bool, bytes, Path)
    and returns either None, a single value, or a list of values
    """

    def __call__(self, **kwargs: DataValue) -> None | DataValue: ...


class Labelable(Protocol):
    """
    A protocol for objects that can have a label.
    This is used to provide a human-readable name for the object.
    """

    @property
    def label(self) -> str | None:
        """
        Return the label of the object.
        If no label is set, return None.
        """
        ...


class Kernel(ContentIdentifiable, Labelable, Protocol):
    """
    Kernel defines the fundamental unit of computation that can be performed on zero, one or more streams of data.
    It is the base class for all computations and transformations that can be performed on a collection of streams
    (including an empty collection).
    A kernel is defined as a callable that takes a (possibly empty) collection of streams as the input
    and returns a new stream as output (note that output stream is always singular).
    Each "invocation" of the kernel on a collection of streams is assigned a unique ID.
    The corresponding invocation information is stored as Invocation object and attached to the output stream
    for computational graph tracking.
    """

    def __call__(
        self, *streams: "Stream", label: str | None = None, **kwargs
    ) -> "Stream":
        """
        This is the main interface for invoking the kernel and perform any side-effects such as registering the invocation with the computational graph.
        This method should be called with a collection of streams, which can be empty, and is expected to trigger
        the call to the forward method of the kernel.
        """
        ...

    def forward(self, *streams: "Stream") -> "Stream":
        """
        Trigger the main computation of the kernel on a collection of streams.
        This method is called when the kernel is invoked with a collection of streams.
        Subclasses should override this method to provide the kernel with its unique behavior.
        The method should return a new stream that represents the output of the kernel, but should not register the invocation
        with the computational graph, allowing for the computation to be performed without side effects.
        """
        ...

    def types(self, *streams: "Stream") -> tuple[TypeSpec, TypeSpec]: ...

    def validate_inputs(self, *streams: "Stream") -> None: ...


class Pod(Kernel, Protocol):
    @property
    def input_typespec(self) -> TypeSpec: ...

    @property
    def output_typespec(self) -> TypeSpec: ...

    def call(self, tag: Tag, packet: Packet) -> tuple[Tag, Packet | None]:
        """
        Call the function pod with a single input packet.
        This is used to invoke the function pod with a single packet.
        """
        ...


class Stream(ContentIdentifiable, Labelable, Protocol):
    """
    A stream that is generated by an invocation of a kernel.
    This stream is used to represent the output of a kernel invocation.
    It is a concrete implementation of the SyncStream that has an associated
    invocation that generated the stream.
    """

    @property
    def source(self) -> Kernel | None: ...

    @property
    def upstreams(self) -> tuple["Stream", ...]: ...

    @property
    def last_modified(self) -> datetime | None:
        """
        Returns when the stream's content was last modified.

        Returns:
            datetime: Timestamp of last modification (cacheable streams)
            None: Content is never stable - always recompute
                  (async streams, dynamic streams, etc.)
        """
        ...

    @property
    def is_current(self) -> bool:
        """
        Returns whether the stream is current.
        A stream is current if the content is up-to-date with respect to its source.
        This can be used to determine if a stream with non-None last_modified is up-to-date.
        Note that for asynchronous streams, this status is not applicable and always returns False.
        """
        ...

    def as_table(self) -> pa.Table:
        """
        Convert the stream to a PyArrow Table.
        To avoid collision, tags should be prefixed with "_tag_".
        """
        ...

    def __iter__(self) -> Iterator[tuple[Tag, Packet]]: ...

    def iter_packets(self) -> Iterator[tuple[Tag, Packet]]: ...

    def keys(self) -> tuple[tuple[str, ...], tuple[str, ...]]:
        """
        Return the keys of the pipeline property.
        This is used to define the keys of the pipeline property.
        """
        ...

    def types(self) -> tuple[TypeSpec, TypeSpec]:
        """
        Return the types of the pipeline property.
        This is used to define the types of the graph property.
        """
        ...


class Source(Kernel, Stream, Protocol):
    """
    A source is a special type of kernel that produces a stream of data.
    It is the entry point for data into the computational graph.
    Sources are typically used to read data from external sources such as files, databases, etc.
    """


class Tracker(Protocol):
    def set_active(self, active: bool = True) -> None:
        """
        Set the active state of the tracker.
        This is used to activate or deactivate the tracker.
        If the tracker is active, it will record the invocations of kernels.
        """
        ...

    def is_active(self) -> bool:
        """
        Check if the tracker is active.
        This is used to determine if the tracker is currently recording invocations.
        """
        ...

    def record(self, stream: Stream) -> None:
        """
        Record the output stream of a kernel invocation in the tracker.
        This is used to track the computational graph and the invocations of kernels.
        """
        ...


class TrackerManager(Protocol):
    def get_active_trackers(self) -> list[Tracker]:
        """
        Get the list of active trackers.
        This is used to retrieve the currently active trackers in the system.
        """
        ...

    def register_tracker(self, tracker: Tracker) -> None:
        """
        Register a new tracker in the system.
        This is used to add a new tracker to the list of active trackers.
        """
        ...

    def deregister_tracker(self, tracker: Tracker) -> None:
        """
        Deregister a tracker from the system.
        This is used to remove a tracker from the list of active trackers.
        """
        ...

    def record(self, stream: Stream) -> None:
        """
        Record the output stream of a kernel invocation in the tracker.
        This is used to track the computational graph and the invocations of kernels.
        """
        ...
