from .types import Tag, Packet
from typing import Optional, Tuple, List, Dict, Any, Collection, Callable, Iterator
from .utils.hash import hash_dict
import networkx as nx


class Operation:
    """
    Operation defines a generic operation that can be performed on a stream of data.
    It is a base class for all operations that can be performed on a collection of streams
    (including an empty collection).
    The operation is defined as a callable that takes a collection of streams as input
    and returns a new stream as output.
    Each invocation of the operation is assigned a unique ID. The corresponding invocation
    information is stored as Invocation object and attached to the output stream.
    """

    def get_invocation(self, *streams: "SyncStream") -> str:
        """
        Given a list of streams to perform the operation on, define
        the invocation ID that would uniquely identify this particular
        invocation of the operation. This ID is used to track each distinct
        invocation of the operation and its associated streams.
        The default implementation is to use the hash of the streams
        as the invocation ID. This is sensitive to the order of the streams.

        For operations that are not sensitive to the order of the streams,
        this method should be overridden to provide a more appropriate
        invocation ID. For example, a join operation may want to use the
        hash of the joined streams instead of the individual stream hashes.
        """
        # default implementation where ID is stream order sensitive
        invocation_id = ":".join([str(hash(s)) for s in streams])
        return Invocation(self, invocation_id, streams)

    def __call__(self, *streams: "SyncStream") -> "SyncStream":
        # if any source is passed in as a stream, invoke it to extract stream first
        from .source import Source

        streams = [s() if isinstance(s, Source) else s for s in streams]

        output_stream = self.forward(*streams)
        # create an invocation instance
        invocation = self.get_invocation(*streams)
        # label the output_stream with the invocation information
        output_stream.source = invocation

        # delay import to avoid circular import
        from .tracker import Tracker

        # reg
        active_trackers = Tracker.get_active_trackers()
        for tracker in active_trackers:
            tracker.record(invocation)

        return output_stream

    def __repr__(self):
        return self.__class__.__name__

    def forward(self, *streams: "SyncStream") -> "SyncStream": ...


class Invocation:
    """
    This class represents an invocation of an operation on a collection of streams.
    It contains the operation, the invocation ID, and the streams that were used
    in the invocation.
    The invocation ID is a unique identifier for the invocation and is used to
    track the invocation in the tracker.
    """

    def __init__(
        self,
        operation: Operation,
        invocation_id: str,
        streams: Collection["SyncStream"],
    ) -> None:
        self.operation = operation
        self.invocation_id = invocation_id
        self.streams = streams

    def __repr__(self) -> str:
        return f"Invocation({self.operation}, ID:{self.invocation_id})"

    def __hash__(self) -> int:
        # TODO: use a better hash function that is based on the operation,
        # invocation_id and the streams (ideally invocation objects attached to the streams)
        return super().__hash__()

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Invocation):
            return False
        return (
            self.operation == other.operation
            and self.invocation_id == other.invocation_id
        )

    def __lt__(self, other: Any) -> bool:
        if not isinstance(other, Invocation):
            return NotImplemented

        if self.operation == other.operation:
            return self.invocation_id < other.invocation_id
        return self.operation < other.operation


class Stream:
    """
    A stream is a collection of tagged-packets that are generated by an operation.
    The stream is iterable and can be used to access the packets in the stream.

    A stream has propery `source` that is an instance of Invocation that generated the stream.
    This may be None if the stream is not generated by an operation.
    """

    def __init__(self):
        self._source: Optional[Invocation] = None

    @property
    def source(self) -> Optional[Invocation]:
        return self._source

    @source.setter
    def source(self, value: Invocation) -> None:
        if not isinstance(value, Invocation):
            raise TypeError("source must be an instance of Invocation")
        self._source = value

    def __iter__(self) -> Iterator[Tuple[Tag, Packet]]:
        raise NotImplementedError("Subclasses must implement __iter__ method")


class SyncStream(Stream):
    """
    A stream that will complete in a fixed amount of time. It is suitable for synchronous operations that
    will have to wait for the stream to finish before proceeding.
    """

    def __hash__(self) -> int:
        return super().__hash__()

    def keys(self) -> Tuple[List[str], List[str]]:
        """
        Returns the keys of the stream.
        The first list contains the keys of the tags, and the second list contains the keys of the packets.
        The keys are returned on based-effort basis, and this invocation may trigger the
        upstream computation of the stream.
        Furthermore, the keys are not guaranteed to be identical across all packets in the stream.
        This method is useful for inferring the keys of the stream without having to iterate
        over the entire stream.
        """
        tag, packet = next(iter(self))
        return list(tag.keys()), list(packet.keys())

    def preview(self, n: int = 1) -> None:
        """
        Print the first n elements of the stream.
        This method is useful for previewing the stream
        without having to iterate over the entire stream.
        If n is <= 0, the entire stream is printed.
        """
        for idx, (tag, packet) in enumerate(self):
            if n > 0 and idx >= n:
                break
            print(f"Tag: {tag}, Packet: {packet}")

    def __len__(self) -> int:
        """
        Returns the number of packets in the stream.
        Note that this method may trigger the upstream computation of the stream.
        This method is not guaranteed to be efficient and should be used with caution.
        """
        return sum(1 for _ in self)
